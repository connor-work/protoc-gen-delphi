/// Copyright 2020 Connor Roehricht (connor.work)
/// Copyright 2020 Sotax AG
/// 
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
/// 
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.

using System.Collections.Generic;
using System.Linq;
using Google.Protobuf.Reflection;
using Work.Connor.Delphi;
using Work.Connor.Delphi.CodeWriter;
using System;

namespace Work.Connor.Protobuf.Delphi.ProtocGenDelphi
{
    /// <summary>
    /// Aggregation of Delphi source code elements that represent a protobuf schema definition.
    /// </summary>
    /// <remarks>
    /// The protobuf schema definition is mapped to a Delphi unit.
    /// </remarks>
    internal class SchemaSourceCode
    {
        /// <summary>
        /// Function that looks up a known protobuf schema definition by name
        /// </summary>
        private readonly Func<string, FileDescriptorProto> lookupProtofile;

        /// <summary>
        /// Support definition for the targetted protobuf runtime
        /// </summary>
        private readonly IRuntimeSupport runtime;

        /// <summary>
        /// Protobuf schema definition to generate code for
        /// </summary>
        public FileDescriptorProto ProtoFile { get; }

        /// <summary>
        /// Protobuf schema definitions imported by this schema
        /// </summary>
        public IEnumerable<SchemaSourceCode> Imports => ProtoFile.Dependency.Select(name => new SchemaSourceCode(lookupProtofile, runtime, lookupProtofile.Invoke(name)));

        /// <summary>
        /// Constructs Delphi source code representing a protobuf schema definition.
        /// </summary>
        /// <param name="lookupProtofile">Function that looks up a known protobuf schema definition by name</param>
        /// <param name="runtime">Support definition for the targetted protobuf runtime</param>
        /// <param name="protoFile">Protobuf schema definition to generate code for</param>
        public SchemaSourceCode(Func<string, FileDescriptorProto> lookupProtofile, IRuntimeSupport runtime, FileDescriptorProto protoFile)
        {
            this.lookupProtofile = lookupProtofile;
            this.runtime = runtime;
            ProtoFile = protoFile;
        }

        // Generated by Visual Studio
        public override bool Equals(object? obj) => obj is SchemaSourceCode code && EqualityComparer<FileDescriptorProto>.Default.Equals(ProtoFile, code.ProtoFile);

        // Generated by Visual Studio
        public override int GetHashCode() => HashCode.Combine(ProtoFile);

        /// <summary>
        /// Delphi source code representations of the top-level protobuf enums
        /// </summary>
        private IEnumerable<EnumSourceCode> TopLevelEnums => ProtoFile.EnumType.Select(@enum => new EnumSourceCode(@enum, this, null));

        /// <summary>
        /// Delphi source code representations of all protobuf enums in the schema
        /// </summary>
        private IEnumerable<EnumSourceCode> Enums => TopLevelEnums.Concat(TopLevelMessageTypes.SelectMany(messageType => messageType.TransitivelyNestedEnums));

        /// <summary>
        /// Delphi source code representations of the top-level protobuf message types
        /// </summary>
        private IEnumerable<MessageTypeSourceCode> TopLevelMessageTypes => ProtoFile.MessageType.Select(messageType => new MessageTypeSourceCode(messageType, this, null));

        /// <summary>
        /// Delphi source code representations of all protobuf message types in the schema
        /// </summary>
        private IEnumerable<MessageTypeSourceCode> MessageTypes => TopLevelMessageTypes.SelectMany(messageType => messageType.TransitivelyNestedMessages);

        /// <summary>
        /// Delphi unit identifier of the generated unit
        /// </summary>
        private UnitIdentifier DelphiUnitIdentifier
        {
            get
            {
                string[] fileNameSegments = ProtoFile.Name.Split(ProtocGenDelphi.protoFileNamePathSeparator);
                // Use namespace that matches the package, if no package is set, match the path
                string[] nameSpaceSegments = ProtoFile.HasPackage ? ProtoFile.Package.Split(".")
                                                                  : fileNameSegments[0..^1];
                // Split off extension from file name
                return ProtocGenDelphi.ConstructUnitIdentifier(nameSpaceSegments, fileNameSegments[^1].Split(".")[0]);
            }
        }

        /// <summary>
        /// Name of the generated Delphi unit
        /// </summary>
        public string DelphiUnitName => DelphiUnitIdentifier.ToSourceCode();

        /// <summary>
        /// Generated Delphi unit
        /// </summary>
        public Unit DelphiUnit => new()
        {
            Heading = DelphiUnitIdentifier,
            Interface = Interface,
            Implementation = Implementation,
            Comment = new() { CommentLines = { UnitComment } }
        };

        /// <summary>
        /// Splits a potentially package-qualified field type name provided by <c>protoc</c> into package and type name.
        /// Returns all possible solutions without testing whether a name segment is part of the type name or package name.
        /// </summary>
        /// <param name="typeName">The (potentially package-qualified) field type name</param>
        /// <returns>For each possible split, the package name (empty if qualified and empty, <c>null</c> if unqualified) and the type name</returns>
        private static IEnumerable<(string? package, string typeName)> SplitTypeName(string fieldTypeName)
        {
            if (!fieldTypeName.StartsWith(".")) yield return (null, fieldTypeName); // Unqualified name
            else
            {
                int dotIndex = fieldTypeName.LastIndexOf(".");
                string unqualifiedName = fieldTypeName.Substring(dotIndex + 1);
                if (dotIndex == 0) yield return ("", unqualifiedName);
                else
                {
                    string qualifier = fieldTypeName[1..dotIndex];
                    // First solution: the qualifier is the entire package name
                    yield return (qualifier, unqualifiedName);
                    // Then work backwards through potential container types
                    foreach ((string? package, string containerTypeName) in SplitTypeName(qualifier)) yield return (package, $"{containerTypeName}.{unqualifiedName}");
                }
            }
        }

        /// <summary>
        /// Determines all available schemata that match a protobuf package name.
        /// </summary>
        /// <param name="package">The package name, absent if no package is specified, empty if the default package is specified</param>
        /// <returns>Sequence of matching schemata in type lookup order</returns>
        private IEnumerable<SchemaSourceCode> GetSchemataInPackage(string? package)
        {
            if (package is null) return new List<SchemaSourceCode> { this };
            if (package == "") return Imports.Prepend(this).Where(import => !import.ProtoFile.HasPackage);
            return Imports.Prepend(this).Where(import => import.ProtoFile.Package == package);
        }

        /// <summary>
        /// Finds the representation of a protobuf enum by field type name. 
        /// </summary>
        /// <param name="typeName">The field type name</param>
        /// <returns>The protobuf enum</returns>
        public EnumSourceCode GetEnum(string typeName) => SplitTypeName(typeName).SelectMany(nameSplit => GetSchemataInPackage(nameSplit.package).SelectMany(schema => schema.Enums)
                                                                                                                                                 .Where(@enum => @enum.ContainerQualifiedTypeName == nameSplit.typeName)
                                                                                            ).First();

        /// <summary>
        /// Finds the representation of a protobuf message type by field type name. 
        /// </summary>
        /// <param name="typeName">The field type name</param>
        /// <returns>The protobuf message type</returns>
        public MessageTypeSourceCode GetMessageType(string typeName) => SplitTypeName(typeName).SelectMany(nameSplit => GetSchemataInPackage(nameSplit.package).SelectMany(schema => schema.MessageTypes)
                                                                                                                                                               .Where(messageType => messageType.ContainerQualifiedTypeName == nameSplit.typeName)
                                                                                                          ).First();

        /// <summary>
        /// Interface section of the generated Delphi unit
        /// </summary>
        private Interface Interface
        {
            get
            {
                Interface @interface = new()
                {
                    UsesClause = { Dependencies },
                    Declarations = { TopLevelEnums.Concat<TypeSourceCode>(TopLevelMessageTypes).Select(type => type.InterfaceDeclaration) }
                };
                @interface.UsesClause.SortUsesClause();
                return @interface;
            }
        }

        /// <summary>
        /// Determines the required unit references within the generated Delphi unit
        /// </summary>
        /// <returns>Sequence of required unit references</returns>
        private IEnumerable<UnitReference> Dependencies => Imports.Select(import => new UnitReference() { Unit = import.DelphiUnitIdentifier })
                                                   .Concat(TopLevelMessageTypes.SelectMany(messageType => messageType.Dependencies(runtime)))
                                                               .Distinct();

        /// <summary>
        /// Implementation section of the generated Delphi unit
        /// </summary>
        private Implementation Implementation => new()
        {
            Declarations = { TopLevelMessageTypes.SelectMany(messageType => messageType.MethodDeclarations)
                                                 .Select(method => new ImplementationDeclaration() { MethodDeclaration = method }) }
        };

        /// <summary>
        /// XML documentation comment for the generated Delphi unit
        /// </summary>
        private IEnumerable<string> UnitComment => // TODO transfer protobuf comment
$@"<remarks>
This unit corresponds to the protobuf schema definition (.proto file) <c>{ProtoFile.Name}</c>.
</remarks>".Lines();
    }
}
